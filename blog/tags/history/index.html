<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.3">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="ESP32 Manager Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="ESP32 Manager Blog Atom Feed">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4LC1CTFLW8"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-4LC1CTFLW8",{})</script><title data-react-helmet="true">One post tagged with &quot;history&quot; | ESP32 Manager</title><meta data-react-helmet="true" property="og:title" content="One post tagged with &quot;history&quot; | ESP32 Manager"><meta data-react-helmet="true" property="og:url" content="https://esp32m.com/blog/tags/history"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_tag" content="blog_tags_posts"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://esp32m.com/blog/tags/history"><link data-react-helmet="true" rel="alternate" href="https://esp32m.com/blog/tags/history" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://esp32m.com/blog/tags/history" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.9a8a25c0.css">
<link rel="preload" href="/assets/js/runtime~main.651586c8.js" as="script">
<link rel="preload" href="/assets/js/main.101f0d2e.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="ESP32 Manager logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="ESP32 Manager logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">ESP32 Manager</b></a><a class="navbar__item navbar__link" href="/docs/intro">Documentation</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/esp32m/core" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">ðŸŒž</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="ESP32 Manager logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="ESP32 Manager logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">ESP32 Manager</b></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/intro">Documentation</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/esp32m/core" target="_blank" rel="noopener noreferrer" class="menu__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div></div></nav><div class="main-wrapper blog-wrapper blog-tags-post-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_2ahu thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_2hhb margin-bottom--md">Recent posts</div><ul class="sidebarItemList_2xAf"><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/going-wire-less">Going Wireless!</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/reliability-quest">Quest for Reliability</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/initial">The story behind</a></li></ul></nav></aside><main class="col col--7"><header class="margin-bottom--xl"><h1>One post tagged with &quot;history&quot;</h1><a href="/blog/tags">View All Tags</a></header><article class="margin-bottom--xl"><header><h2 class="blogPostTitle_GeHD"><a href="/blog/initial">The story behind</a></h2><div class="blogPostData_291c margin-vert--md"><time datetime="2021-06-01T00:00:00.000Z">June 1, 2021</time> Â· 9 min read</div><div class="avatar margin-vert--md"><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/dyarkovoy" target="_blank" rel="noopener noreferrer">Denis Yarkovoy</a></div><small class="avatar__subtitle"></small></div></div></header><div class="markdown"><p>It started as a simple home automation project. I was looking for a way to do the most basic things like track temperature/humidity, switch the lights, open water valve in the greenhouse, turn on the fan when it gets too hot, etc. So I looked into some ready-made automation kits and... decided to have some fun building my own!
The idea was to set up WiFi-capable devices all over the place (luckily, my WiFi coverage allows that) and wire them to the switches/relays/sensors etc.
My first try was Raspberry PI + USB relay module, driven by a python script. Works well for one or two locations, but if you want a dozen - it is an overkill and gets pricey.
The next thing I tried was STM32 (&quot;Blue Pill&quot;) module wired to ESP8266. STM32 is great to read multiple sensors and control several devices, but doesn&#x27;t have any networking features. ESP8266 is a WiFi chip, but has a very limited number of I/O ports. Together they make a great combo, but there are cons. For example, I had to maintain 2 different firmwares, implement a protocol for the chips to talk to each other, put up with reliability issues because all connections were manually soldered and looked like this:</p><p><img alt="Manually connected ESP822 and STM32" src="/assets/images/esp8266_stm32_soldered-dfeae5b83b86e5e4d73f313e07bc5880.jpg">
Another thing is the amount of available RAM/flash, that is pretty restrictive on both chips.</p><p>Finally, I found this beautiful ESP32 module that had everything I could ever think of, and more - in a single tiny module, for a very competitive price (N.B.: no, I&#x27;m not paid to advertise ESP32, nor am I affiliated with Espressif in any way. I was just truly fascinated by the chip). </p><p><img alt="ESP32-S module" src="/assets/images/esp32-s-9b595c94e2735ac2f251d27035186b92.jpg"></p><p>Now I could easily connect 5 different sensors, 2 relays, 2 H-bridges, several LEDs and a buzzer, and make it all accessible over WiFi! The last missing piece of the puzzle was the software. At first, Arduino seemed like a very natural choice. There&#x27;s support for ESP32, you get access to all the modules that mostly work well, the community is great, learning is easy, and it is a de-facto standard for simple MCU projects.
But... there&#x27;s a flipside:</p><ul><li>Arduino is too unified. It attempts to cover all sorts of MCUs, with different goals, features, hardware capabilities and design principles. What if I need access to hardware-specific features of ESP32, that aren&#x27;t available, let&#x27;s say, in STM32? ESP32 has its own development platform (<a href="//docs.espressif.com/projects/esp-idf/en/latest/esp32/index.html" target="_blank" rel="noopener noreferrer">ESP-IDF</a>), and if you really want to get the most of the hardware, you have to use ESP-IDF. The problem is, Arduino went its own way. It accesses <em>some</em> of the hardware directly, bypassing the ESP-IDF. It runs startup code to initialize Arduino-specific features, which was not desirable in my case. It uses pre-configured (and, possibly, patched) version of ESP-IDF, and if you want to re-configure it for your particular needs (which is a common practice for ESP-IDF application), you&#x27;re in for another challenge. So what happens if I want to use Arduino and ESP-IDF at the same time, without dirty hacks and workarounds? Seems like mission impossible, but no. There&#x27;s a wonderful <a href="//platformio.org/platforms/espressif32" target="_blank" rel="noopener noreferrer">PlatformIO</a>, that&#x27;s not only a better alternative to Arduino&#x27;s native IDE, but also allows to use Arduino as a library, on top of ESP-IDF! Now this should be the <em>Ultimate Solution</em>, I thought... and faced another handful of issues.</li><li>Arduino wasn&#x27;t designed for multitasking. No, it is perfectly possible to do multitasking in Arduino, there are scheduling libraries that offer pseudo-multitasking, and if there&#x27;s native MCU support (which is the case for double-core ESP32) - you can always call native functions directly. At the same time, most of the Arduino libraries don&#x27;t expect to be run in a multitasking environment, they don&#x27;t care about synchronization, locking and race conditions, so one has to either patch the source, or apply various hacks to achieve stable performance. One example would be the <a href="//github.com/PaulStoffregen/OneWire" target="_blank" rel="noopener noreferrer">OneWire library</a>. This is a well-designed and mature library that works perfectly on AVR, STM32 (and I would expect, on other single-core MCUs in a single-thread mode). OneWire protocol depends on proper timing, so the library disables interrupts when sending/receiving data packets, with the naive belief that interrupts are the only possible cause of inaccurate time measurements and prolonged delays. Wrong! ESP32 context switches must be disabled as well, or the code must be re-designed to allow for a context switch to occur safely at the very moment when the protocol expects to see state change on the 1WIRE bus. As a result, this library fails consistently on ESP32 with multiple running tasks. For me, only about 30% of the measurements were successful and the rest were failing. The workaround was suggested and implemented by <a href="//github.com/stickbreaker" target="_blank" rel="noopener noreferrer">Chuck Todd</a> in <a href="//github.com/stickbreaker/OneWire" target="_blank" rel="noopener noreferrer">his fork of OneWire library</a>. It is pretty straightforward - disable context switches for the duration of 1WIRE reads/writes, and voila, it works! But what about the rest of the tasks? Now they can&#x27;t run until 1WIRE has finished its business... Far, far from perfect, IMHO.</li><li>As I mentioned above, Arduino sometimes accesses the hardware directly, by reading/writing memory-mapped registers and ports. ESP-IDF does the same. So for the most of common stuff like writing to the serial port, we have 2 similar blocks of code that need to be included in the resulting binary, unnecessarily bloating its size.</li><li>Using Arduino as a library together with ESP-IDF requires some (heavy - i think) modifications of both cores. Given that this is a community effort, there&#x27;s a (substantial) time lag to see new ESP-IDF releases ported to PlatformIO&#x27;s way of using it together with Arduino. For me, this was the last drop and I made a tough decision in favor of ESP-IDF alone, dropping Arduino completely, and never regretted it.</li></ul><p>I don&#x27;t know about you, but if I read this far, I would be puzzled. Multitasking? Concerns about firmware size? Just to switch a relay or get a temperature reading? The OP must be going nuts! Actually, that could be the case. After a couple of successful ESP32-driven projects, I got greedy. I wanted to see more and more features, and, the most important, I was not constrained by Arduino any longer. Here&#x27;s what I wanted to achieve:</p><ul><li>True multitasking, so I could poll for a sensor in a simple loop and not worry about blocking other tasks.</li><li>Modular architecture - a simple <code>#include &lt;XXX&gt;</code> followed by a call to <code>useXXX(...);</code> should be enough to make use of an external device attached to ESP32.</li><li>Extensible design - adding new devices (or porting from Arduino) should be easy.</li><li>Unified communication protocol to speak to the outer world - whether to get a sensor reading, or to send a control command to switch a relay - via different communication channels (serial port, MQTT, HTTP, WebSockets, etc). Human-readable. JSON-based.</li><li>Unified logic for loading, using and storing module-specific settings. Human-readable. JSON-based.</li><li>Unified asynchronous event dispatching system to tie different modules together, while reducing dependencies between the modules to a minimum.</li><li>Over-the-air firmware updates with few simple clicks or unattended - when new firmware becomes available on the server.</li><li>Logging with configurable appenders, for example, to save error logs to the flash memory and retrieve it when needed, or to send the log messages instantly to rsyslog server over UDP - very useful feature for debugging new code without physical access to the chip and/or it&#x27;s UART0.</li><li>Get sensor readings into <a href="//www.influxdata.com/" target="_blank" rel="noopener noreferrer">influxdb</a> time series database via MQTT and <a href="//www.influxdata.com/time-series-platform/telegraf/" target="_blank" rel="noopener noreferrer">Telegraf</a> and visualize it with <a href="//www.influxdata.com/time-series-platform/chronograf/" target="_blank" rel="noopener noreferrer">Chronograf</a>, or any other time-series database/UI.</li><li>Allow to configure multiple WiFi APs and select optimal/available one automatically.</li><li>If no WiFi SSID/password was pre-configured in the firmware, or no connection could be made within configured time frame, launch AP with captive portal, allowing to connect from any smartphone and configure WiFi options.</li><li>Comprehensive Web-based User Interface (yes, I&#x27;m that crazy)!<ul><li>Single page <a href="//reactjs.org" target="_blank" rel="noopener noreferrer">ReactJS</a> - based app.</li><li>WebSockets to read/write state and settings of the running firmware and control attached devices.</li><li>Modular design - follows backend modules.</li><li>Served directly from the ESP32&#x27;s IP address over WiFi, with an option to be served from a different server (to save flash space, for instance)</li><li>Displays general system/runtime info, such as RAM/flash usage/fragmentation, uptime, WiFi connection details, per-task info, </li><li>Allows to control pin modes from UI (switch between digital/ADC/DAC/PWM/...), read/write pin state, voltage, PWM duty/freq., etc.</li><li>Allows to scan popular buses for connected devices (I2C and MODBUS - get connected devices&#x27; addresses, 1WIRE - get codes of connected devices).</li></ul></li><li>All of the above - in the reusable library, with only the needed code to be included into the binary for a particular project.</li><li>Must fit in the 2MB (actually, a little less) to make OTA updates possible on a standard ESP32 dev module with 4MB SPI Flash.</li><li>Supervisor app:<ul><li>Controls multiple devices via WebSockets API.</li><li>Provides simple higher-level scripting API with something as simple as Javascript, to run custom scenarios (for example, if the rain is detected by device A, tell device B to close the window).</li><li>Notifications to <a href="//t.me" target="_blank" rel="noopener noreferrer">Telegram</a> channel or any other messenger.</li><li>No central server - I don&#x27;t want to pay for a VPS, domain a static IP. Rather, I want to have it on a couple of Raspberries (behind the NAT, dynamic IP) and make it accessible from any part of the world. <a href="//www.torproject.org/docs/tor-onion-service" target="_blank" rel="noopener noreferrer">TOR hidden services</a> is one way to make it work.</li></ul></li></ul><p>Looking back, it&#x27;s been about 6 months of part-time engagement, and most of the above (except the supervisor app) was implemented to a (not perfect, but) usable extent. I have 11  setups, driving different devices and feeding sensor data into the Influx server running on a Raspberry. Most of the boards have had an uptime of &gt; 30 days (the rest have hardware issues due to manual soldering, caught by WDTs causing auto-reboot every now and then). </p><p>So I thought maybe there are other crazy guys and girls like me out there, who enjoy this stuff as much, and decided to share the source/docs. It may help enthusiasts to build something alike, to learn the MCU or just to have fun! :-)</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><a class="margin-horiz--sm" href="/blog/tags/esp-32-m">esp32m</a><a class="margin-horiz--sm" href="/blog/tags/source">source</a><a class="margin-horiz--sm" href="/blog/tags/history">history</a><a class="margin-horiz--sm" href="/blog/tags/initial">initial</a><a class="margin-horiz--sm" href="/blog/tags/commit">commit</a></div><div class="col text--right"><a aria-label="Read more about The story behind" href="/blog/initial"><b>Read More</b></a></div></footer></article></main></div></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Getting Started</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/reference/project-structure">Reference</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/esp32m/core" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://t.me/esp32m" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Telegram<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2021</div></div></div></footer></div>
<script src="/assets/js/runtime~main.651586c8.js"></script>
<script src="/assets/js/main.101f0d2e.js"></script>
</body>
</html>