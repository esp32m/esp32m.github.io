"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2179],{2162:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>i,default:()=>g,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var s=n(5893),o=n(1151);const r={sidebar_position:4},i="Remote Logging",l={id:"tutorial/remote-logging",title:"Remote Logging",description:"ESP32 Manager contains a tiny logger module that is able to send output to multiple independent appenders. esp32m library contains, among others, 2 appenders able to send log messages to remote servers for storage and analysis. This feature may be extremely helpful when debugging applications, especially when no physical access to the ESP32 chip or its UART0 is available.",source:"@site/docs/tutorial/remote-logging.md",sourceDirName:"tutorial",slug:"/tutorial/remote-logging",permalink:"/docs/tutorial/remote-logging",draft:!1,unlisted:!1,editUrl:"https://github.com/esp32m/website/edit/master/website/docs/tutorial/remote-logging.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"OTA updates",permalink:"/docs/tutorial/ota"},next:{title:"Monitoring sensors",permalink:"/docs/tutorial/sensor-monitoring"}},a={},d=[{value:"Logging to <strong>rsyslog</strong>",id:"logging-to-rsyslog",level:2},{value:"Server setup",id:"server-setup",level:3},{value:"Appender setup",id:"appender-setup",level:3},{value:"Checking output",id:"checking-output",level:3},{value:"Logging to MQTT",id:"logging-to-mqtt",level:2},{value:"Client and server setup",id:"client-and-server-setup",level:3},{value:"Appender setup",id:"appender-setup-1",level:3},{value:"Checking output",id:"checking-output-1",level:3}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"remote-logging",children:"Remote Logging"}),"\n",(0,s.jsx)(t.p,{children:"ESP32 Manager contains a tiny logger module that is able to send output to multiple independent appenders. esp32m library contains, among others, 2 appenders able to send log messages to remote servers for storage and analysis. This feature may be extremely helpful when debugging applications, especially when no physical access to the ESP32 chip or its UART0 is available."}),"\n",(0,s.jsxs)(t.h2,{id:"logging-to-rsyslog",children:["Logging to ",(0,s.jsx)(t.strong,{children:"rsyslog"})]}),"\n",(0,s.jsx)(t.h3,{id:"server-setup",children:"Server setup"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"//www.rsyslog.com/",children:"RSYSLOG"})," daemon is included by default in the majority of modern Linux distributions. Is capable of collecting remote log messages over the TCP or UDP protocol. Many distributions have this feature disabled by default, so we need a little tweak to enable it. Open ",(0,s.jsx)(t.code,{children:"/etc/rsyslog.conf"})," and make sure that the following lines are un-commented:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'module(load="imudp")\r\ninput(type="imudp" port="514")\n'})}),"\n",(0,s.jsx)(t.p,{children:"Now restart the rsyslog daemon and check that it is listening on UDP port 514::"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-shell",children:"$ sudo systemctl restart rsyslog\r\n$ sudo netstat -nlp | grep rsyslogd\n"})}),"\n",(0,s.jsx)(t.p,{children:"if everything is right, you should see something like this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"udp        0      0 0.0.0.0:514             0.0.0.0:*                           9335/rsyslogd\r\nudp6       0      0 :::514                  :::*                                9335/rsyslogd\n"})}),"\n",(0,s.jsx)(t.h3,{id:"appender-setup",children:"Appender setup"}),"\n",(0,s.jsxs)(t.p,{children:["Add the following code to your ",(0,s.jsx)(t.code,{children:"main.cpp"})," to enable UDP logging to ",(0,s.jsx)(t.strong,{children:"rsyslog"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"#include <esp32m/log/udp.hpp>\r\n\r\n...\r\n\r\nlog::addBufferedAppender(new log::Udp());\n"})}),"\n",(0,s.jsxs)(t.p,{children:["By default, UDP appender looks for ",(0,s.jsx)(t.code,{children:"syslog.lan"})," name on your local network. You can just add this name to the ",(0,s.jsx)(t.code,{children:"/etc/hosts"})," file on the machine with the ",(0,s.jsx)(t.strong,{children:"rsyslog"})," server, or add static name to your local DNS. Alternatively, you can pass IP or DNS name of your ",(0,s.jsx)(t.strong,{children:"rsyslog"})," server to the ",(0,s.jsx)(t.code,{children:"new log::Udp()"})," statement."]}),"\n",(0,s.jsx)(t.h3,{id:"checking-output",children:"Checking output"}),"\n",(0,s.jsxs)(t.p,{children:["If everything is set up correctly, you should start seeing log messages from your ESP32 in the /var/log/syslog. It is also possible to redirect these messages to separate file or files. Refer to ",(0,s.jsx)(t.a,{href:"//www.rsyslog.com/",children:"RSYSLOG"})," documentation for details."]}),"\n",(0,s.jsx)(t.h2,{id:"logging-to-mqtt",children:"Logging to MQTT"}),"\n",(0,s.jsxs)(t.p,{children:["If you need remote logging, ",(0,s.jsx)(t.strong,{children:"rsyslog"})," option is generally the best due to low footprint and the best possible performance. However, if you don't have access to a Linux machine with ",(0,s.jsx)(t.strong,{children:"rsyslog"}),", or if you want to capture log messages in your own MQTT-enabled application, MQTT logging may be useful."]}),"\n",(0,s.jsx)(t.h3,{id:"client-and-server-setup",children:"Client and server setup"}),"\n",(0,s.jsxs)(t.p,{children:["Refer to ",(0,s.jsx)(t.a,{href:"/docs/tutorial/mqtt",children:"MQTT setup"})," tutorial page for details."]}),"\n",(0,s.jsx)(t.h3,{id:"appender-setup-1",children:"Appender setup"}),"\n",(0,s.jsxs)(t.p,{children:["Add the following code to your ",(0,s.jsx)(t.code,{children:"main.cpp"})," to enable UDP logging to ",(0,s.jsx)(t.strong,{children:"rsyslog"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"#include <esp32m/log/mqtt.hpp>\r\n\r\n...\r\n\r\nlog::addBufferedAppender(&log::Mqtt::instance());\n"})}),"\n",(0,s.jsx)(t.h3,{id:"checking-output-1",children:"Checking output"}),"\n",(0,s.jsx)(t.p,{children:"Run this command on the computer with MQTT server to see log messages:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-shell",children:"$ mosquitto_sub -t 'esp32m/log/#'\n"})})]})}function g(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>l,a:()=>i});var s=n(7294);const o={},r=s.createContext(o);function i(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);