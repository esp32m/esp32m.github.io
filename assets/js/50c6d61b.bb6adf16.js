"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2221],{6619:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var n=i(5893),s=i(1151);const a={sidebar_position:3},o="OTA updates",r={id:"tutorial/ota",title:"OTA updates",description:"OTA (Over-The-Air) feature allows flashing new applications using a WiFi connection, by downloading the application binary from a remote HTTP server.",source:"@site/docs/tutorial/ota.md",sourceDirName:"tutorial",slug:"/tutorial/ota",permalink:"/docs/tutorial/ota",draft:!1,unlisted:!1,editUrl:"https://github.com/esp32m/website/edit/master/website/docs/tutorial/ota.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"MQTT setup",permalink:"/docs/tutorial/mqtt"},next:{title:"Remote Logging",permalink:"/docs/tutorial/remote-logging"}},l={},c=[{value:"OTA update methods",id:"ota-update-methods",level:2},{value:"Setting up automatic checking for updates",id:"setting-up-automatic-checking-for-updates",level:3},{value:"Setting up the HTTP server",id:"setting-up-the-http-server",level:2},{value:"Setting up OTA client",id:"setting-up-ota-client",level:2},{value:"Partition table considerations",id:"partition-table-considerations",level:2},{value:"Updating the application using arbitrary URL",id:"updating-the-application-using-arbitrary-url",level:2},{value:"From the User Interface",id:"from-the-user-interface",level:3},{value:"Using the WebSockets API",id:"using-the-websockets-api",level:3},{value:"Using the MQTT API",id:"using-the-mqtt-api",level:3}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"ota-updates",children:"OTA updates"}),"\n",(0,n.jsx)(t.p,{children:"OTA (Over-The-Air) feature allows flashing new applications using a WiFi connection, by downloading the application binary from a remote HTTP server."}),"\n",(0,n.jsx)(t.h2,{id:"ota-update-methods",children:"OTA update methods"}),"\n",(0,n.jsx)(t.p,{children:"There are 2 methods to update your application:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Let the user provide the URL of the updated application. This method is easier to set up, but less secure, as the user can potentially install any application, unrelated to the particular hardware, malicious or disfunctional. We recommend using this method only for debugging."}),"\n",(0,n.jsx)(t.li,{children:"Have ESP32M check for updates automatically and install new versions. We recommend using this method for production builds. This method requires a JSON configuration file on the server that describes available versions of your application."}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"setting-up-automatic-checking-for-updates",children:"Setting up automatic checking for updates"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["Set the name and version of your application in the file ",(0,n.jsx)(t.code,{children:"CMakeLists.txt"})," at the top of your project directory:"]}),"\n"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:'...\r\nset(PROJECT_VER "1.1.0")\r\nproject(my-app)\n'})}),"\n",(0,n.jsx)(t.p,{children:"The version must contain 3 positive integers separated by two dots. The first two are the major and minor version numbers, and the third one is the patch or build number."}),"\n",(0,n.jsxs)(t.ol,{start:"2",children:["\n",(0,n.jsxs)(t.li,{children:["Set the following configuration options in ",(0,n.jsx)(t.code,{children:"sdkconfig"})," or via ",(0,n.jsx)(t.code,{children:"idf.py menuconfig"}),":"]}),"\n"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.code,{children:"CONFIG_ESP32M_NET_OTA_CHECK_FOR_UPDATES=y"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.code,{children:'CONFIG_ESP32M_NET_OTA_VENDOR_URL="https://your_server.com/<folder_with_updates>"'})}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"CONFIG_ESP32M_NET_OTA_CHECK_INTERVAL=XX"}),", where ",(0,n.jsx)(t.code,{children:"XX"})," is how often to check for updates (minutes)"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"CONFIG_ESP32M_NET_OTA_VENDOR_ONLY=y"})," if you don't want to allow users to install arbitrary binary files (default). If this option is not set, the user will be able to provide any URL and install any firmware."]}),"\n"]}),"\n",(0,n.jsxs)(t.ol,{start:"3",children:["\n",(0,n.jsxs)(t.li,{children:["Upload the ",(0,n.jsx)(t.code,{children:"<my-app>.json"})," file to the ",(0,n.jsx)(t.code,{children:"/<folder_with_updates>"})," on your server. The name of this file must match the name of the application (as configured with the ",(0,n.jsx)(t.code,{children:"project()"})," command in the ",(0,n.jsx)(t.code,{children:"CMakeLists.txt"}),"). The format of the file is as follows:"]}),"\n"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-json",children:'{ "firmware": { "1.1.2": "path/to/app.bin" } }\n'})}),"\n",(0,n.jsxs)(t.p,{children:["The file describes versions of the application available on the server. The path to the application binary is relative to the ",(0,n.jsx)(t.code,{children:".json"})," file."]}),"\n",(0,n.jsxs)(t.ol,{start:"4",children:["\n",(0,n.jsxs)(t.li,{children:["Upload the application binary to the server so it can be downloaded at ",(0,n.jsx)(t.code,{children:"https://your_server.com/<folder_with_updates>/path/to/app.bin"})]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"setting-up-the-http-server",children:"Setting up the HTTP server"}),"\n",(0,n.jsxs)(t.p,{children:["Use any HTTP server of your choice (for example, ",(0,n.jsx)(t.a,{href:"//www.nginx.com/",children:"Nginx"}),"). The server must allow binary file downloads and must be accessible to your ESP32 device either by IP or by DNS name. It is advisable to set up TLS encryption (",(0,n.jsx)(t.code,{children:"https://"})," protocol), especially if you plan to update your application over the Internet, to enforce the integrity of your application. One of the easiest ways to set up a free TLS certificate is by using a ",(0,n.jsx)(t.a,{href:"//certbot.eff.org/",children:"Certbot"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"setting-up-ota-client",children:"Setting up OTA client"}),"\n",(0,n.jsx)(t.p,{children:"OTA module must be included and initialized in your project, like this:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:"#include <esp32m/net/ota.hpp>\n"})}),"\n",(0,n.jsxs)(t.p,{children:["at the start of your ",(0,n.jsx)(t.code,{children:"main.cpp"}),", and"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:"net::useOta();\n"})}),"\n",(0,n.jsxs)(t.p,{children:["in the ",(0,n.jsx)(t.code,{children:"void app_main()"})]}),"\n",(0,n.jsx)(t.h2,{id:"partition-table-considerations",children:"Partition table considerations"}),"\n",(0,n.jsxs)(t.p,{children:["The OTA update process is a native ESP-IDF feature explained in detail in ",(0,n.jsx)(t.a,{href:"//docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/ota.html",children:"this article"}),". In short, ESP-IDF maintains at least two separate slots of the same size in the partition table (ota_0 and ota_1), of which one is currently running the application, and the other one is used to download a new application. If the download process is successful and all integrity checks are OK, the second partition becomes active, while the first one will accept the\r\napplication binary on the next update, and so on. This approach allows to survive incomplete or broken updates but requires twice as much flash memory. Therefore ESP32 module with 4MB SPI flash will allow for an application size of a little less than 2MB. If you want to use OTA with a bigger application or need flash space for other purposes, consider the ESP32 module with an 8MB or 16MB flash chip."]}),"\n",(0,n.jsx)(t.h2,{id:"updating-the-application-using-arbitrary-url",children:"Updating the application using arbitrary URL"}),"\n",(0,n.jsxs)(t.p,{children:["This method is available if automatic checking for updates is not configured, or if ",(0,n.jsx)(t.code,{children:"CONFIG_ESP32M_NET_OTA_VENDOR_ONLY"})," is not set in ",(0,n.jsx)(t.code,{children:"sdkconfig"})]}),"\n",(0,n.jsx)(t.h3,{id:"from-the-user-interface",children:"From the User Interface"}),"\n",(0,n.jsxs)(t.p,{children:["Click on the ",(0,n.jsx)(t.code,{children:"System"})," link in the sidebar menu and enter the application URL in the ",(0,n.jsx)(t.code,{children:"Administration"})," box, then click Update:"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"administration",src:i(7595).Z+"",width:"574",height:"272"})}),"\n",(0,n.jsxs)(t.p,{children:["If the progress bar appears in a few seconds - the update process has started, and must not be interrupted until finished. You will not be able to use the device during the update process. When the update is finished, the MCU will reboot automatically and should become accessible again within a few seconds. If the progress bar doesn't appear for a long time (over 20 seconds), it usually means that the MCU cannot download the application binary for some reason. Check the URL, make sure that you can download application from a browser and check if your firewall blocks the MCU. You can also set up ",(0,n.jsx)(t.a,{href:"/docs/tutorial/remote-logging",children:"Remote logging"})," to check for extended error/warning messages."]}),"\n",(0,n.jsx)(t.h3,{id:"using-the-websockets-api",children:"Using the WebSockets API"}),"\n",(0,n.jsx)(t.p,{children:"Establish WebSockets connection with your ESP32 and send this message to start application update:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-json",children:'{\r\n  "type": "request",\r\n  "target": "ota",\r\n  "name": "update",\r\n  "data": { "url": "https://my-server.net/firmware/my-firmware.bin" }\r\n}\n'})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"/docs/reference/api#websockets",children:"See details"})," on WebSockets API"]}),"\n",(0,n.jsx)(t.h3,{id:"using-the-mqtt-api",children:"Using the MQTT API"}),"\n",(0,n.jsx)(t.p,{children:"Send the message"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-json",children:'{ "url": "https://my-server.net/firmware/my-firmware.bin" }\n'})}),"\n",(0,n.jsxs)(t.p,{children:["to the target ",(0,n.jsx)(t.code,{children:"esp32m/request/project_name/ota/update"})," (replace ",(0,n.jsx)(t.code,{children:"project_name"})," with the name of your project)"]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"/docs/reference/api#mqtt",children:"See details"})," on MQTT API"]})]})}function h(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},7595:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/administration-71cf5ba4cd58098f0f6383bbe76f24b1.png"},1151:(e,t,i)=>{i.d(t,{Z:()=>r,a:()=>o});var n=i(7294);const s={},a=n.createContext(s);function o(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);